import os
import time
from random import random

import matplotlib.pyplot as plt
import networkx as nx
from annotation import *


class Config:
    def __init__(self):
        self.POSTGRES_HOST = "localhost"
        self.POSTGRES_PORT = 5432
        self.POSTGRES_DBNAME = "TPC-H"
        self.POSTGRES_USERNAME = "postgres"
        self.POSTGRES_PASSWORD = "password123"
        self.FLASK_ENV = "development"

        self.project_root = os.getcwd()

class Node:
    def __init__(self, query_plan, comparison):
        """Initialises a node with its relevant query plan.
        Parse each attribute of the plan and set as an attribute of the object, such as:
        1. Node type
        2. Total Cost
        3. Plan Rows
        etc.

        Args:
            query_plan (dict):  Query plan that is generated by PostgreSQL
        """
        self.plans = []
        for key in query_plan:
            setattr(self, key.lower().replace(" ", "_"), query_plan.get(key))
        explainer = Annotation.annotation_dict.get(self.node_type, default_annotation)
        self.explanation = explainer(query_plan, comparison)

    def __str__(self):
        """Overrides the __str__ method to represent the class objects as a string.

        Returns:
            str: String representation of Node.
        """
        return f"{self.node_type}\ncost: {self.total_cost}"


class QueryPlan:
    def __init__(self, query, comparison):
        """Initialises the root node with the root query plan.
        Constructs the graph and calculate attributes of the QEP:
        1. Total cost
        2. Plan rows
        3. Number of sequential scan nodes
        4. Number of index scan nodes
        4. Explanation of the query plan

        Args:
            query (dict): Query plan that is generated by PostgreSQL
        """
        self.graph = nx.DiGraph()
        self.root = Node(query, comparison)
        self.construct_graph(self.root, comparison)
        self.total_cost = self.calculate_total_cost()
        self.plan_rows = self.calculate_plan_rows()
        self.num_seq_scan_nodes = self.calculate_num_nodes("Seq Scan")
        self.num_index_scan_nodes = self.calculate_num_nodes("Index Scan")
        self.explanation = self.create_explanation(self.root)

    def construct_graph(self, root, comparison):
        """Constructs the graph recursively by forming an edge between each node
        and each of its child nodes.

        Args:
            root (Node): The parent node.
        """
        self.graph.add_node(root)
        for child in root.plans:
            child_node = Node(child, comparison)
            self.graph.add_edge(root, child_node)
            self.construct_graph(child_node, comparison)

    def create_explanation(self, node: Node) -> str:
        """Creates explanation of the entire QEP recursively by combining the explanations
        for each node.

        Args:
            node (Node): Each node in the graph representing the QEP.

        Returns:
            string: The complete explanation of the QEP.
        """
        result = []
        for child in self.graph[node]:
            result += self.create_explanation(child)
        result += [node.explanation]
        return result

    def calculate_num_nodes(self, node_type: str) -> int:
        """Calculate the total number of nodes in the query with a specified node type.

        Args:
            node_type (str): Type of node (e.g. Seq Scan, Index Scan)

        Returns:
            int: Number of nodes with the specified node type.
        """
        num_nodes = 0
        for node in self.graph.nodes:
            if node.node_type == node_type:
                num_nodes += 1
        return num_nodes

    def calculate_plan_rows(self) -> int:
        """Calculate the total plan rows of the QEP via the summation of individual plan rows of each node.

        Returns:
            int: Total plan rows of QEP
        """
        plan_rows = 0
        for node in self.graph.nodes:
            plan_rows += node.plan_rows
        return plan_rows

    def calculate_total_cost(self) -> int:
        """Calculate the total cost of the QEP via the summation of individual cost of each node.

        Returns:
            int: Total cost of QEP
        """
        total_cost = 0
        for node in self.graph.nodes:
            total_cost += node.total_cost
        return total_cost

    def save_graph_file(self) -> str:
        """Renders the graph and save the figure as an .png file
        in the 'static' folder.
        The frontend then renders the image on the UI to visualise the QEP.

        Returns:
            str: File name of graph
        """
        graph_name = f"qep_{str(time.time())}.png"
        dev_config = Config()
        file_name = os.path.join(dev_config.project_root, "static", graph_name)
        plot_formatter_position = get_tree_node_pos(self.graph, self.root)
        node_labels = {x: str(x) for x in self.graph.nodes}
        nx.draw(
            self.graph,
            plot_formatter_position,
            with_labels=True,
            labels=node_labels,
            font_size=6,
            node_size=300,
            node_color="skyblue",
            node_shape="s",
            alpha=1,
        )
        plt.savefig(file_name)
        plt.clf()
        return graph_name


def get_tree_node_pos(G, root=None, width=1.0, height=1, vert_gap=0.1, vert_loc=0, xcenter=0.5):
    """From Joel's answer at https://stackoverflow.com/a/29597209/2966723.
    Licensed under Creative Commons Attribution-Share Alike

    Recursive program to define the positions. The recursion happens in _hierarchy_pos, which is called by get_tree_node_pos.
    The main role of hierarchy_pos is to do a bit of testing to make sure the graph is appropriate before entering the recursion.

    If the graph is a tree this will return the positions to plot this in a hierarchical layout.

    Args:
        G (DiGraph): The graph (must be a tree).
        root (Node, optional): The root node of the current branch.
        - If the tree is directed and this is not given, the root will be found and used.
        - If the tree is directed and this is given, the positions will be just for the descendants of this node.
        - If the tree is undirected and not given, a random choice will be used.
        Defaults to None.
        width (float, optional): Horizontal space allocated for this branch. Defaults to 1.0.
        height (int, optional): Vertical space allocated for this branch. Defaults to 1.
        vert_gap (float, optional):  Gap between levels of hierarchy. Defaults to 0.1.
        vert_loc (int, optional): Vertical location of root. Defaults to 0.
        xcenter (float, optional): Horizontal location of root. Defaults to 0.5.

    Raises:
        TypeError: Graph is not a tree.

    Returns:
        dict: [description]
    """

    if not nx.is_tree(G):
        raise TypeError("cannot use hierarchy_pos on a graph that is not a tree")

    if root is None:
        if isinstance(G, nx.DiGraph):
            root = next(iter(nx.topological_sort(G)))  # allows back compatibility with nx version 1.11
        else:
            root = random.choice(list(G.nodes))

    path_dict = dict(nx.all_pairs_shortest_path(G))
    max_height = 0
    for value in path_dict.values():
        max_height = max(max_height, len(value))
    vert_gap = height / max_height

    def _hierarchy_pos(
        G,
        root,
        width,
        vert_gap,
        vert_loc,
        xcenter,
        pos=None,
        parent=None,
        min_dx=0.05,
    ):
        """Refer to get_tree_node_pos docstring for most arguments.

        Args:
            parent (Node, optional): Parent of the current branch. (Only affects it if non-directed). Defaults to None.

        Returns:
            [dict]: a dict that maps each node to its corresponding location if they have been assigned.
        """

        if pos is None:
            pos = {root: (xcenter, vert_loc)}
        else:
            pos[root] = (xcenter, vert_loc)
        children = list(G.neighbors(root))
        if not isinstance(G, nx.DiGraph) and parent is not None:
            children.remove(parent)
        if len(children) != 0:
            dx = max(min_dx, width / len(children))
            nextx = xcenter - width / 2 - max(min_dx, dx / 2)
            for child in children:
                nextx += dx
                pos = _hierarchy_pos(
                    G,
                    child,
                    width=dx,
                    vert_gap=vert_gap,
                    vert_loc=vert_loc - vert_gap,
                    xcenter=nextx,
                    pos=pos,
                    parent=root,
                )
        return pos

    return _hierarchy_pos(G, root, width, vert_gap, vert_loc, xcenter)